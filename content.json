{"meta":{"title":"Tri's","subtitle":"一些關於前端技術的筆記和剪貼簿","description":null,"author":"Trina Lu","url":"http://tri613.github.io"},"pages":[],"posts":[{"title":"Node server with Docker","slug":"node-server-with-docker","date":"2017-08-03T10:18:27.000Z","updated":"2017-09-20T03:25:43.104Z","comments":true,"path":"2017/08/03/node-server-with-docker/","link":"","permalink":"http://tri613.github.io/2017/08/03/node-server-with-docker/","excerpt":"我發現Docker基本原則是這樣的，就是 一個container只運行一個服務一個container只運行一個服務一個container只運行一個服務 （很重要所以說三遍） 所以以前我們可能會把 nginx + node 全部都一起裝在一台VM上，但現在如果要把它docker化，就變成要開兩個container，一個nginx一個node server的服務。而不是直接開一個ububtu(之類的)的container然後把全部東西灌在上面build成一個image。","text":"我發現Docker基本原則是這樣的，就是 一個container只運行一個服務一個container只運行一個服務一個container只運行一個服務 （很重要所以說三遍） 所以以前我們可能會把 nginx + node 全部都一起裝在一台VM上，但現在如果要把它docker化，就變成要開兩個container，一個nginx一個node server的服務。而不是直接開一個ububtu(之類的)的container然後把全部東西灌在上面build成一個image。 所以如果要把上述的東西docker化，檔案結構會長成這樣12345678/ (專案根目錄)| -- docker-compose.yml` -- node| | -- index.js| | -- Dockerfile`-- nginx| | -- nginx.conf| | -- Dockerfile 完整範例可以參考我的 github Docker安裝走這邊：(ubuntu 16.04)https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04 一些名詞簡介OK，所以到底啥是 Dockerfile ? 啥又是 docker-compose ? Dockerfile 其實它就是用來 build image 的步驟描述檔。 如果你要建立image檔，有兩種方式： 先下載一個base image (像是ubuntu or centos那種)，就像是開一台VM一樣，然後在你開起來的那個container裡面做平常你會在VM裡面做的事情，再把這個container的狀態commit上去變成一個image檔。 把你所有要做的事情寫成一個 Dockerfile，然後直接下指令build就好!! 我覺得寫 Dockerfile 的好處是，你不用真的把你的image推到像是docker hub的地方，而是直接給別人你的 Dockerfile + 需要的源碼讓人家去build就好感覺這樣進版本庫也比較輕量(?) docker-compose一開始提到了，Docker的基本原則是，一個container只負責一項服務但基本上不太可能一個APP只用到一個服務 (像是本文就用到了 node + nginx)所以需要 docker-compose 來一次幫你把你的 APP (服務群?) 開好(不然也是可以自己先把所有的image build好再一個個開起來啦只是會開到起笑) 那怎麼知道要開哪些服務哩? 這時候就需要用到 docker-compose.yml 這個設定檔了而這個設定檔怎麼寫，下面會有範例所以這邊不多說了 所以兩者關係是這樣的： 一個 Dockerfile 可以build成一個 image，一個 container 則是一個 image 的實體，而 docker-compose.yml 就是描述很多個 container (or service) 之間的交互作用。(吧) 好像沒有很總結到的感覺XDDDD，直接往下看程式比較快(ㄜ) nodeindex.js（毫無反應，就只是個node server） 陽春到極致的簡單範例： 12345678910const http = require(&apos;http&apos;)const port = process.env.PORT || 8080const requestHandler = function handler(req, res) &#123; res.end(&quot;Hello! This is a simple node server!&quot;)&#125;const server = http.createServer(requestHandler)server.listen(port, () =&gt; console.log(`Node simple server is now listening on *:$&#123;port&#125;`)) Dockerfile building from ubuntu 1234567891011121314FROM ubuntu:trusty# install curl &amp; nodeRUN apt-get update &amp;&amp; \\ apt-get -y install curl &amp;&amp; \\ curl -sL https://deb.nodesource.com/setup_7.x | bash - &amp;&amp; \\ apt-get install -y nodejsWORKDIR /srcADD . /srcEXPOSE 8080CMD [&quot;node&quot;, &quot;/src/index.js&quot;] building from node (with pm2) 直接用官方的node image環境當底，這個方法build起來速度快很多XD 12345678910FROM node:7.10.1RUN npm install pm2 -gWORKDIR /srcCOPY . /srcEXPOSE 8080CMD [&quot;pm2-docker&quot;, &quot;process.yml&quot;] process.yml 這個是 pm2 在用的啦，順便列一下 12345apps: - script : &apos;./index.js&apos; name : &apos;node-server&apos; exec_mode: &apos;cluster&apos; instances: 4 EXPOSE 好像只是讓大家知道 container 打算要使用哪個port，真正要運行的時候，還是需要加上類似-p xxxx:8080這樣的東西。 但因為我們不會直接build images出來，而是透過 docker-compose 來建立整套服務，所以到時候寫在 docker-compose.yml裡面就可以了。 手動 build image 並啟動假如沒有要透過 docker-compose 而只是想要啟用單一服務的話，也可以先手動建立image然後啟動。 Dockerfile 就是拿來build image用的，所以我們現在其實已經擁有所有需要的素材了。 先切到 node 本身的目錄下面：1$ cd your-project/node 建立image：1$ docker build -t your-namespace/node . build完以後執行啟動 1$ docker run -d -p 3000:8080 your-namespace/node 連到 *:3000 就可以看到我們的node伺服器正常運作中拉，Hooray! nginxnginx.conf這 nginx 的 config 也是直接複製網路上範例，(所以我沒有深究它在幹嘛XD)注意連到 node server 的服務的時候用的是 http://nodejs:8080其中 nodejs 是寫在 docker-compose.yml裡面 node server的 nameport 則是當初在 node Dockerfile 裡面EXPOSE指定的 port 123456789101112131415161718worker_processes 4;events &#123; worker_connections 1024; &#125;http &#123; server &#123; listen 80; location / &#123; proxy_pass http://nodejs:8080; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &apos;upgrade&apos;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &#125; &#125;&#125; nginx config 參數配置參考 http://www.ha97.com/5194.html Dockerfile123FROM nginxCOPY nginx.conf /etc/nginx/nginx.conf docker-composedocker-compose.yml首先在根目綠下面加上 docker-compose.yml 這個檔案它主要就是來告訴 docker-compose 說要開哪些服務然後這些服務彼此之間的關係等等 12345678910nginx: build: ./nginx links: - nodejs:nodejs ports: - &quot;80:80&quot;nodejs: build: ./node ports: - &quot;8080&quot; # 對外沒有port!!!!! 所以外面的人是無法直接連到 node 服務的 啟動在專案根目錄下面執行：1$ docker-compose up -d 注意 docker-compose 是要另外裝的，所以沒有要記得裝。 詳細安裝教學：(ubuntu 16.04)https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-16-04 然後就好啦!!! 更新假如更新程式的話怎麼辦?????像是我的 node 裡面的程式碼如果更新了要怎麼辦??? 因為我這邊用的是 COPY，所以基本上程式碼算是和docker分開管理(的吧) 我現在的想像是整個project都進版本庫管理然後在專案底下執行 git pull or svn up 之類的完畢後，使用 1$ docker-compose up --build -d 來建立新版本並更新。 (而且我發現這可以在已經執行中的狀態下使用，可以無痛更新ㄚ!!!!!) 注意 --build 這個參數，如果沒有用的話他就會使用已經建立過的版本下去跑，這樣你更新的程式碼就完全沒用了~ 其他很多像是 ADD 跟 COPY 差在哪啦，什麼樣的更新方式比較OK啦這類的細節和討論我不是很清楚，總之先可以跑起來就好了XD (欸) 參考資料 http://anandmanisankar.com/posts/docker-container-nginx-node-redis-example/ http://schempy.com/2015/08/25/docker_nginx_nodejs/","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://tri613.github.io/tags/node-js/"},{"name":"nginx","slug":"nginx","permalink":"http://tri613.github.io/tags/nginx/"},{"name":"linux","slug":"linux","permalink":"http://tri613.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"http://tri613.github.io/tags/docker/"}]},{"title":"Node production server","slug":"node-production-server","date":"2017-07-20T03:17:13.000Z","updated":"2017-09-20T03:22:22.808Z","comments":true,"path":"2017/07/20/node-production-server/","link":"","permalink":"http://tri613.github.io/2017/07/20/node-production-server/","excerpt":"看了一下大家似乎是用nginx + pm2在作這些事情但我覺得多一個pm2就好麻煩喔為什麼要這樣逼大家嗚嗚不曉得如果要弄到ec2上又是怎樣MIS真的不是人在幹的(。","text":"看了一下大家似乎是用nginx + pm2在作這些事情但我覺得多一個pm2就好麻煩喔為什麼要這樣逼大家嗚嗚不曉得如果要弄到ec2上又是怎樣MIS真的不是人在幹的(。 環境 Ubuntu 16.04 node v7.10.1 npm v4.2.0 安裝各種東西設定網路 &amp; 安裝 openssh server1$ sudo apt install openssh-server 沒有CURL的話1sudo apt-get update; sudo apt-get install curl 安裝 node 推薦方法 12345# Install Node.js 7.x repositorycurl -sL https://deb.nodesource.com/setup_7.x | bash -# Install Node.js and npmapt-get install -y nodejs 用nvm (buggy) 會buggy的原因是nvm都灌在使用者自己的根目錄下面如果到別的地方要用or sudo就會怪怪的但我不想修這種bug所以果斷放棄^^ 12$ apt-get update$ curl https://raw.githubusercontent.com/creationix/nvm/v0.25.0/install.sh | bash 如果出現 Close and reopen your terminal to start using nvm不想重開可以打下面的指令 1$ source ~/.profile 1$ nvm install 7 安裝 nginx1$ sudo apt-get install nginx 安裝 pm21$ sudo npm install -g pm2 設定 nginx1$ sudo vim /etc/nginx/sites-available/default 寫成像下面這樣 1234567891011121314151617181920212223242526272829303132333435363738server &#123; listen 80; return 301 https://$host$request_uri;&#125;server &#123; listen 443; server_name tri.example.com; ssl_certificate /etc/nginx/cert.crt; ssl_certificate_key /etc/nginx/cert.key; ssl on; ssl_session_cache builtin:1000 shared:SSL:10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!RC4; ssl_prefer_server_ciphers on; access_log /var/log/nginx/example.access.log; location / &#123; proxy_pass http://localhost:8080; # proxy_read_timeout 90; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_redirect http://localhost:8080 https://tri.example.com; &#125;&#125; 設定完記得重啟一下就行。 1$ sudo service nginx restart SSL上面那個有設定ssl，憑證開發用的可以自簽雖然瀏覽器會說你這個是可怕的網站但沒關係Production再換成正式憑證就好自簽憑證：1$ sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/cert.key -out /etc/nginx/cert.crt 參考資料：https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04 IP判斷在 Server block裡面簡單加上12allow 192.168.13.13deny all 之類的就可以了。 但如果有load balance什麼東西等等，就要透過 ngx_http_realip_module 來獲取client真實IP，這我沒設過但下面有兩篇蠻清楚的講解文，下次再試。 https://leo108.com/pid-2132.asp https://www.x4b.net/kb/RealIP-Nginx 架 node server我都放在 /var/www/ 下面，這邊就只是把code clone下來放著(?) 12$ cd /var/www$ sudo git clone https://some-git-repository.git myproject 備註Nginx 基本上就是真正對外的server，所以為了不讓外面的人有辦法直接連到node server，可以把 node server綁在一個IP上 (像是localhost) express範例如下： 1app.listen(port, '127.0.0.1', () =&gt; console.log(`Express server is listening on *:$&#123;port&#125;`)); 這樣外面的人就無法透過IP直接連到node server了。(也有人說你就直接設防火牆就好了ㄚ) 使用 pm2 啟動 node server現在有了node server的程式碼，就只差把它啟動而已雖然我也很想直接 node index.js 就好但如果它突然中斷我會很害怕所以只好靠 pm2 來幫忙 寫 pm2 設定檔因為我有用到 NODE_ENV 去區分我要連線的DB，所以寫一個config檔放在專案的根目錄裡 1234567891011121314151617181920// pm2.config.jsmodule.exports = &#123; apps : [ &#123; name: \"push-usagi\", script: \"./index.js\", watch: true, ignore_watch: [\"node_modules\"], env: &#123; \"NODE_ENV\": \"development\" &#125;, env_testing: &#123; \"NODE_ENV\": \"testing\" &#125;, env_production: &#123; \"NODE_ENV\": \"production\" &#125; &#125; ]&#125;; 啟動因為我有寫config檔，所以就用config檔來作為啟動設定(?) 先切到專案目錄下 1$ cd /var/www/myproject 然後執行pm2啟動 node server 1$ pm2 start pm2.config.js --env production 看一下它的狀態 1$ pm2 ls 好了，它開起來了。現在它如果意外被關閉會自己重啟，而因為有設定 watch的選項，更新程式的時候它會自己reload server。 開機時自動啟動pm2程序1$ pm2 startup systemd 這一步都是已經把我要自動開的service開起來後才作的，照我的理解是，如果作這步的時候沒有service之後開完要再輸入 1$ pm2 save 才可以，但我沒有試成功過就是了。 上面做完如果重開VM不用作任何事情就可以連到網頁就大功告成啦。:v: 其他pm2還有支援一些deploy &amp; load balance等等的機制，但這對我來說太over了所以暫時就這樣吧有需要可以翻翻他們的githubpm2 on github SO? Why nginx? 都裝完了才在問 (。 看起來nginx在以下項目上的表現會比直接用node server好，或者是寫node處理會太繁瑣： serve static files gzip load balance (across machine or port的那種，不是node本身的cluster，而是真的開很多node server的load balance) 同一台server要架很多站 (virtual host) 綁 80 or 443 port (主要是權限問題，如果可以sudo執行好像就沒差) SSL (但node本身也可以設SSL，大家是說這樣比較不好，但到底哪裡不好也沒特別提囧) 關於SSL這邊有提到是效率問題：Does your Node.js code need a web server to run? a more proper error handling (至少當你node server crash的時候大家連進來還會有 502 bad gateway) 減少application server (like node, python…) 本身的loading 所以說不是不能直接裸開node server，只是使用nginx來處理某些事情會更輕鬆可靠，大家才會建議這麼做吧。 (那我的API server到底有沒有必要呢…感覺除了SSL好像都沒差…) 參考資料 How To Set Up a Node.js Application for Production on Ubuntu 16.04 How To Use PM2 to Setup a Node.js Production Environment On An Ubuntu VPS NGINX 設定 HTTPS 網頁加密連線，建立自行簽署的 SSL 憑證 5 Performance Tips for Node.js Applications Deploying django in a production server","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://tri613.github.io/tags/node-js/"},{"name":"nginx","slug":"nginx","permalink":"http://tri613.github.io/tags/nginx/"},{"name":"linux","slug":"linux","permalink":"http://tri613.github.io/tags/linux/"}]},{"title":".bind(), .apply() and .call()","slug":"bind-apply-and-call","date":"2017-06-15T06:25:31.000Z","updated":"2017-06-20T05:19:19.003Z","comments":true,"path":"2017/06/15/bind-apply-and-call/","link":"","permalink":"http://tri613.github.io/2017/06/15/bind-apply-and-call/","excerpt":"常常忘記這三個在幹嘛所以整理一下日後好查詢。","text":"常常忘記這三個在幹嘛所以整理一下日後好查詢。 .bind()1func.bind(thisArg[, arg1[, arg2[, ...]]]); bind doesn’t execute function immediately,but returns wrapped apply function with certain context (for later execution): 123456789function greeting(name) &#123; this.hello = this.hello || \"Hello\"; return `$&#123;this.hello&#125;, $&#123;name&#125;!`;&#125;const greetingInJapanese = greeting.bind(&#123;hello: \"こんばんわ\"&#125;);greeting(\"Trina\"); // Hello, Trina!greetingInJapanese(\"Trina\"); // こんばんわ, Trina! .apply() / .call().call() or .apply() invokes the funciton immediately, and modify the context. 12func.call(context, argument1, argument2, ...);func.apply(context, [argument1, argument2, ...]); NoticeBeware that arrow functions could not be bound to another context. MDN: Arrow function #No binding of this Sources http://stackoverflow.com/questions/15455009/javascript-call-apply-vs-bind the this bug in javascript","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://tri613.github.io/tags/javascript/"}]},{"title":"Javascript's by value and by reference","slug":"by-value-and-by-reference","date":"2017-01-22T16:26:39.000Z","updated":"2017-06-20T05:19:56.739Z","comments":true,"path":"2017/01/23/by-value-and-by-reference/","link":"","permalink":"http://tri613.github.io/2017/01/23/by-value-and-by-reference/","excerpt":"這篇筆記是從 Javascript30 的 Day14 - JavaScript References VS Copying 整理下來的。 記得在stackoverflow上面也有人提出其實JS沒有分所謂的by value和by reference，而是以變數的值是否immutable的差別來區分，不過我覺得這樣子的分法對我來說比較好理解。","text":"這篇筆記是從 Javascript30 的 Day14 - JavaScript References VS Copying 整理下來的。 記得在stackoverflow上面也有人提出其實JS沒有分所謂的by value和by reference，而是以變數的值是否immutable的差別來區分，不過我覺得這樣子的分法對我來說比較好理解。 1. By Value (Copying)一般來說只要是 strings, numbers 和 booleans，都可以說是 by value。 12345let a = \"string\";let b = a;console.log(a, b); // \"string\", \"string\"b = \"another string\";console.log(a, b); // \"string\", \"another string\" 2. By Reference如果是 array 或者 object，則會以 by reference 的方式傳遞。 12345678910111213let person1 = &#123; name: \"Trina\", age: 100, gender: \"female\"&#125;;let person2 = person1;console.log(person1, person2);//Object &#123;name: \"Trina\", age: 100, gender: \"female\"&#125;, Object &#123;name: \"Trina\", age: 100, gender: \"female\"&#125;person2.name = \"Sherry\";console.log(person2.name); //\"Sherry\"console.log(person1.name); //\"Sherry\" --&gt; person1 has been changed too! Array 也是一樣的道理： 123456789let players = [\"Trina\", \"Sherry\", \"Pisuke\", \"Kuma\"];let team = players;console.log(players, team);// [\"Trina\", \"Sherry\", \"Pisuke\", \"Kuma\"],// [\"Trina\", \"Sherry\", \"Pisuke\", \"Kuma\"]team[3] = \"Usagi\";console.log(players);// [\"Trina\", \"Sherry\", \"Pisuke\", \"Usagi\"] --&gt; players has been changed too! 要解決這個問題，就必須把Object或Array直接Copy一份才行。 Copying an array 12345//以下幾種方式皆可行const teamCopy1 = players.slice();const teamCopy2 = [].concat(players);const teamCopy3 = [...players]; //es6const teamCopy4 = Array.from(players); Copying an object 123const personCopy = Object.assign(&#123;&#125;, person, &#123; newProperty: \"some additional property for personCopy\"&#125;); 要注意的是以上的方法是 Shallow copy，如果 Object 本身是二維以上的話，使用上面的方式還是會有 By reference的情況發生。 1234567891011121314let me = &#123; name: \"Trina\", age: 24, social: &#123; twitter: \"@tri613\", github: \"tri613\" &#125;&#125;;let me2 = Object.assign(&#123;&#125;, me);me2.social.twitter = \"@nomoney\";console.log(me.social);//&#123;twitter: \"@nomoney\", github: \"tri613\"&#125; --&gt; Changed! 這種情況需要靠Deep clone來解決，最簡單 (但效率表現沒那麼好) 的方式 是直接使用JSON格式encode再decode的方式解決。 1const meCopy = JSON.parse(JSON.stringify(me)); 其他的方式可以參考stackoverflow上面的這篇。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://tri613.github.io/tags/javascript/"},{"name":"i-dont-know-JS","slug":"i-dont-know-JS","permalink":"http://tri613.github.io/tags/i-dont-know-JS/"}]},{"title":"Click events not working on Safari","slug":"safari-click-event","date":"2017-01-12T15:54:29.000Z","updated":"2017-06-20T05:20:14.291Z","comments":true,"path":"2017/01/12/safari-click-event/","link":"","permalink":"http://tri613.github.io/2017/01/12/safari-click-event/","excerpt":"Safari 無法觸發點擊事件今天準備要下班的時候被同事抓住說safari上出現了一個bug，說按鈕怎樣點擊都沒有反應，並且只有safari有這個問題。 原本以為是js又出了什麼問題，殊不知用console直接trigger點擊事件完全ＯＫ證明了是safari無法捕捉到使用者點擊的事件。 後來一查發現這根本是個safari的bug，官方還偷偷把這部分的說明拿掉（囧），根本就是想偷偷把bug隱藏起來啊！！！（重點是這個bug你又沒修掉！！！） 僅此紀錄解決方法，以後大家少走點冤枉路。ＱＱ","text":"Safari 無法觸發點擊事件今天準備要下班的時候被同事抓住說safari上出現了一個bug，說按鈕怎樣點擊都沒有反應，並且只有safari有這個問題。 原本以為是js又出了什麼問題，殊不知用console直接trigger點擊事件完全ＯＫ證明了是safari無法捕捉到使用者點擊的事件。 後來一查發現這根本是個safari的bug，官方還偷偷把這部分的說明拿掉（囧），根本就是想偷偷把bug隱藏起來啊！！！（重點是這個bug你又沒修掉！！！） 僅此紀錄解決方法，以後大家少走點冤枉路。ＱＱ 原因 其實它就是bug，結束。（欸） 看mdn上面的說法是因為safari自己有定義哪些elements是可點擊哪些是不可點擊的，所以如果點擊對象是nonclickable，自然就不會觸發click event。（啊結果你官方文件又沒說你定義哪些是可點擊的！！！簡直要爆氣！！！） 還好MDN上面有列出來，可以看這邊參考。 解法紀錄一下兩個我覺得比較實用的解法備存。（不然哪天文件消失又要哭哭了ＱＱ） 為點擊對象添加 cursor: pointer 的css style 添加onclick=&quot;void(0)&quot;的屬性 我今天是使用加css的方式，然後就好了。（囧）Apple我明明這麼相信你的技術力啊！！！！！ 參考文件 iOS Safari 点击事件无效(我今天倉促的找到第一個解法來源是這裡，超級感謝ＱＱ) MDN: click#Safari_Mobile 至於Apple自己的官方文件則是都被移掉了⋯⋯徹底無言⋯⋯","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://tri613.github.io/tags/ios/"},{"name":"safari","slug":"safari","permalink":"http://tri613.github.io/tags/safari/"}]},{"title":"Javascript closure","slug":"javascript-closure","date":"2016-12-15T04:50:54.000Z","updated":"2017-06-20T05:20:50.751Z","comments":true,"path":"2016/12/15/javascript-closure/","link":"","permalink":"http://tri613.github.io/2016/12/15/javascript-closure/","excerpt":"Closure一直是我覺得JS裡面很玄的東西，最近又熊熊想到(?)回去好好看它，這篇主要是記錄自己卡點的地方，如果有錯歡迎指正。","text":"Closure一直是我覺得JS裡面很玄的東西，最近又熊熊想到(?)回去好好看它，這篇主要是記錄自己卡點的地方，如果有錯歡迎指正。 定義Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions ‘remember’ the environment in which they were created. Mozilladeveloper.mozilla.org/en-US/docs/Web/JavaScript/Closures Closures can simply be defined as an inner function in JavaScript has the access to all variable define in outer functions.So when a function is invoked in JavaScript , it creates a new execution context. This context has access to Parent objects with the arguments for current function get invoked, this execution context also has access to the variables declared outside of its scope. Programming Concepts Helpconceptf1.blogspot.tw/2013/11/javascript-closures.html 考慮以下的例子： greeting 被賦值的時候，會觸發並執行 anonymous function，這個anonymous function則會回傳另一個function。而這個function，也就是閉包，它記住了它的環境上下文，所以它可以取得在它scope之外的變數 me，即使 me 的值被改變，greeting仍然可以取得 me 正確的值。 這就是一個最簡單的closure。 Creating closures in loops: A common mistakeMozilla關於Closure的文件上有一段Creating closures in loops: A common mistake，裡面的例子我卡了很久才想通：(這邊是直接用Mozilla上面的fiddle) 照理來說，我們希望在focus不同input的時候，會出現各自的提示訊息，但這邊卻只會顯示最後一筆 Your age (you must be over 16)。原因是在創建onfocus的callback的時候，它其實是一個closure，所以它記得的是被創建時的上下文，也就是說onfocus被觸發的時候，它的callback會知道去哪裡找 item.help 的值，但在for loop完了之後，item.help的值已經變成 Your age (you must be over 16)了，而這也是為什麼上面的範例中，不管選哪個它都只會顯示同一個訊息。 12345678for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125;&#125;// 在for loop外面印出itemconsole.log(item); // &#123;'id': 'age', 'help': 'Your age (you must be over 16)'&#125; 所以說Closure基本上就是一個inner function會記得被創建時的外層上下文環境，而這個inner function可以取得parent scope的變數，它知道變數該指向的對象，但並不包含變數當下的值。 Creating closures in loops: Solutions解法在 Mozilla 上面都有提供，這邊稍微再補充那裡面提到的第一種方式。 根據 Mozilla 的說明，之前 for loop 會出問題，是因為所有的callback function在創建時，全部都指向了同一個環境，所以指向的item都會是同一個，不像上面是各自創了一個獨立環境。 這個說法對我來說有點抽象，我比較喜歡Programming Concepts Help的解釋： If we pass a parameter function makes its own local copy of the variable (if it is not object type which pass by reference). So each time function has its own local copy of variable which not get updated by loop iteration. 豁然開朗啊！JS真是博大精深。(謎) 參考資料 Mozilla - Closures Programming Concepts Help","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://tri613.github.io/tags/javascript/"}]},{"title":"Setup Google login","slug":"google-login","date":"2016-11-23T05:53:46.000Z","updated":"2017-06-20T05:21:04.494Z","comments":true,"path":"2016/11/23/google-login/","link":"","permalink":"http://tri613.github.io/2016/11/23/google-login/","excerpt":"假設已經在 Google API Console 完成專案的建置並取得Client Id了，有三種方式可以設置Google登入。","text":"假設已經在 Google API Console 完成專案的建置並取得Client Id了，有三種方式可以設置Google登入。 1. Setup with meta12345678&lt;!-- set client id in meta --&gt;&lt;meta name=\"google-signin-client_id\" content=\"your-client-id.apps.googleusercontent.com\"&gt;&lt;!-- load google library --&gt;&lt;script src=\"https://apis.google.com/js/platform.js\" async defer&gt;&lt;/script&gt;&lt;!-- set up login btn with classname `g-signin2` --&gt;&lt;div id=\"google-login-btn\" class=\"g-signin2\" data-onsuccess=\"onSuccess\"&gt;&lt;/div&gt; 2. Setup with gapi.auth212345&lt;!-- load google library and specify callback function --&gt;&lt;script src=\"https://apis.google.com/js/platform.js?onload=onloadCallback\" async defer&gt;&lt;/script&gt;&lt;!-- set up login btn (no classname needed, only ID) --&gt;&lt;div id=\"google-login-btn\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324//implement callback functionvar auth2;function onloadCallback() &#123; gapi.load('auth2', function() &#123; auth2 = gapi.auth2.init(&#123; client_id: 'your-client-id.apps.googleusercontent.com' &#125;); //attach event callback for clicking login btn auth2.attachClickHandler('google-login-btn', &#123;&#125;, onSuccess, onFailure); &#125;); //render the default style google btn gapi.signin2.render('google-login-btn');&#125;function onSuccess (googleUser) &#123; var profile = googleUser.getBasicProfile(); console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead. console.log('Name: ' + profile.getName()); console.log('Image URL: ' + profile.getImageUrl()); console.log('Email: ' + profile.getEmail());&#125;function onFailure(error) &#123; console.log(error);&#125;; 在這可以取得使用者的token讓後端去驗證使用者身分，並進行一些登入手續處理。（像是寫Session幹嘛的） 123456789101112131415//modify the onSuccess function to get user token and send it to serverfunction onSuccess (googleUser) &#123; var id_token = googleUser.getAuthResponse().id_token; sendUserTokenToServer(id_token);&#125;function sendUserTokenToServer(token) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/verify-user-token.php'); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.onload = function() &#123; console.log('Signed in as: ' + xhr.responseText); &#125;; xhr.send('token=' + token);&#125; 1234567891011121314151617181920212223//verify-user-token.php$token = $_POST['token'];$ch = curl_init();curl_setopt_array($ch, array( CURLOPT_URL =&gt; 'https://www.googleapis.com/oauth2/v3/tokeninfo?id_token='.$token, CURLOPT_RETURNTRANSFER =&gt; true, CURLOPT_POST =&gt; \"GET\", CURLOPT_SSL_VERIFYPEER =&gt; false, CURLOPT_SSL_VERIFYHOST =&gt; false));$response = curl_exec($ch);curl_close($ch);$data = json_decode($response);//記得先驗證 $data-&gt;aud 是否和client-id相同if ($data-&gt;aud == MY_CLIENT_ID) &#123; echo $data-&gt;name; //here's the user name! echo $data-&gt;sub; //使用者的 unique google id&#125; else &#123; echo 'User not valid.';&#125; 3. Login with backend server (導頁)也可以選擇直接用後端和Google溝通，這樣就不需要載入Google的JS函式庫或寫任何的js script，只需要在前端頁面加上連到登入導頁的連結即可。 Google本身提供了許多語言的sdk，這邊我使用的是 Google’s api php client。 實作這個功能至少需要兩個頁面(吧)： Redirect to Google page這個Redirect to Google page只需要單純實現導頁至Google登入頁面即可。 123456789101112//signin.phprequire_once '/your/path/to/vendor/autoload.php';$client = new Google_Client();$client-&gt;setAuthConfig('/your/path/to/client_secret.json'); //這個json檔可以從Google API Console下載取得$client-&gt;addScope('profile');//set redirect uri$client-&gt;setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/callback.php');$auth_url = $client-&gt;createAuthUrl();header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL));exit(); check all the scopes that you can use here. Google Callback page使用者在Google登入頁面上登入完畢後，Google會導回當初在前面設定的Redirect URI，並附上GET參數code。Redirect URI必須存在於Google API Console的設定裡面。 一開始我一直收到 redirect_uri_mismatch 的錯誤，不知道是不是我在同一個憑證下設了兩個redirect_uri的關係，反正我後來直接重開一個新的憑證就好了。(囧) 123456789101112//callback.phprequire_once '/your/path/to/vendor/autoload.php';$client = new Google_Client();$client-&gt;setAuthConfig('/your/path/to/client_secret.json');$client-&gt;addScope('profile');$client-&gt;authenticate($_GET['code']);$token = $client-&gt;getAccessToken();$token_data = $client-&gt;verifyIdToken(); 123456789101112131415161718192021222324252627//tokenArray( [access_token] =&gt; [token_type] =&gt; [expires_in] =&gt; [id_token] =&gt; [created] =&gt; )//token_dataArray( [iss] =&gt; [exp] =&gt; [at_hash] =&gt; [aud] =&gt; //檢查這個欄位是否和專案的client_id相同 [sub] =&gt; //uid [email_verified] =&gt; [azp] =&gt; [email] =&gt; [name] =&gt; [picture] =&gt; [given_name] =&gt; [family_name] =&gt; [locale] =&gt; ) 然後就可以透過 $token_data 取得使用者資料和他的uid(sub)了。 $client-&gt;verifyIdToken() 和上面提到 verify-user-token.php的功能是一樣的，只是這邊是用SDK直接問，上面則是用curl的方式去問 google api 而已。 完整範例 這是我自己測試時寫的程式碼，我把它放在github上。 參考文件 Google Sign-In for Websites其實方法大致上都可以在官方文件中找到，上面有些範例也是從官方來的，只是我覺得官方文件不夠友善，有些東西都只說一半還得自己另外google。(囧) OAuth 2.0 Scopes for Google APIs Google API Client Libraries","categories":[],"tags":[{"name":"google","slug":"google","permalink":"http://tri613.github.io/tags/google/"},{"name":"social-login","slug":"social-login","permalink":"http://tri613.github.io/tags/social-login/"}]},{"title":"APNs with HTTP/2","slug":"apns-http2","date":"2016-11-21T09:02:24.000Z","updated":"2017-06-20T05:24:29.528Z","comments":true,"path":"2016/11/21/apns-http2/","link":"","permalink":"http://tri613.github.io/2016/11/21/apns-http2/","excerpt":"這篇是從tumblr上面搬來的，當時發表時間是2016/08/12。 其實我也沒有接過第一版的iOS推播，不過被交付survey新版文件的工作， 就稍微記錄一下幾項看完的重點XD","text":"這篇是從tumblr上面搬來的，當時發表時間是2016/08/12。 其實我也沒有接過第一版的iOS推播，不過被交付survey新版文件的工作， 就稍微記錄一下幾項看完的重點XD 因為anps新版api用的是 HTTP/2，為了能夠與他們的server溝通， PHP版本需要 &gt;= 5.5.24 (我們只有5.4.40) Curl的library版本需要 &gt;= 7.38.0 (我們只有7.19.7) OpenSSL &gt;= 1.0.2e (我們只有1.0.1e) 看起來它需要新的憑證，而這個新版憑證沒有所謂的 ‘test’ 或者是 ‘production’之分，只要建好了， 不管是測試環境還是正式環境都可以使用。以下是官方文件中的摘錄： The HTTP/2-based provider API lets you use a single certificate for both development and production environments. For details on obtaining an Apple Push Notification service (APNs) certificate that works in both environments, read Creating a Universal Push Notification Client SSL Certificate. 新版的運作方式可以不用建立socket，可以改用curl POST方法， 除了接口 &amp; 憑證 (還有程式環境版本問題)，其他內容格式(ex. payload)應該是差不多的。 payload的大小限制從2kb -&gt; 4kb 如果在短時間內一直瘋狂重開連線，apple會認定你是在攻擊然後就把連線關閉。(官方文件好像沒有特別提到後續的處理或結果) 現在新版api會立即回傳response給你，不像之前舊版如果發生錯誤還會有時間差。 至於舊版的錯誤處理，官方文件有提供一些建議 基本上應該就是一直寫一直寫，寫到壞掉的時候，(fwrite的結果為false?) 有可能是滿了或怎樣，就再試著寫一次， 如果還是寫不進去就讀讀看，如果回傳大小為0，就表示連線可能因為是大小問題or格試錯誤等等被關掉了， 但假如大小為6bytes，就表示他們有回傳錯誤訊息，然後就可以根據錯誤訊息debug一下這樣。 －－っと、原本是這樣想的，但在stackoverflow看到有人說 $result is always true not mathers if sending was successful or not 看來是我想得太天真ㄌ… ※備註：在這裡有人提到： Any errors cause the TCP socket to be closed, even if valid notifications had been sent over the connection after a single invalid one. This often happens in cases where developers might accidentally mixed push identifiers between Development and Production versions of their app. 感覺我們舊版偶爾會爆炸可能就是因為這個……","categories":[],"tags":[{"name":"apns","slug":"apns","permalink":"http://tri613.github.io/tags/apns/"},{"name":"ios","slug":"ios","permalink":"http://tri613.github.io/tags/ios/"},{"name":"push","slug":"push","permalink":"http://tri613.github.io/tags/push/"}]},{"title":"在mac上設置apache + php + mysql","slug":"mamp","date":"2016-11-21T08:52:52.000Z","updated":"2017-06-20T05:23:58.873Z","comments":true,"path":"2016/11/21/mamp/","link":"","permalink":"http://tri613.github.io/2016/11/21/mamp/","excerpt":"前前提要這篇是從tumblr上面搬來的，當時發表時間是2016/08/25。 前情提要一下本人上上禮拜敗了一台mac pro，想說架個伺服器以便未來開發 原本在windows下我都是懶惰直接灌wamp或xampp這種一次打包好的東西， 所以本來想說mac也來找找有沒有類似的就好了（←很懶 殊不知估狗一下才發現原來mac有內建阿帕契！甚至連PHP都已經裝好了！！ 只有mysql需要自己灌，真是太神拉~~~（灑花） 不過話是這樣說，實際上在setup的過程中還是碰到了不少問題（中途甚至不小心玩壞怒重灌了一次XD），所以還是記錄一下整個過程好了。","text":"前前提要這篇是從tumblr上面搬來的，當時發表時間是2016/08/25。 前情提要一下本人上上禮拜敗了一台mac pro，想說架個伺服器以便未來開發 原本在windows下我都是懶惰直接灌wamp或xampp這種一次打包好的東西， 所以本來想說mac也來找找有沒有類似的就好了（←很懶 殊不知估狗一下才發現原來mac有內建阿帕契！甚至連PHP都已經裝好了！！ 只有mysql需要自己灌，真是太神拉~~~（灑花） 不過話是這樣說，實際上在setup的過程中還是碰到了不少問題（中途甚至不小心玩壞怒重灌了一次XD），所以還是記錄一下整個過程好了。 # 環境 作業系統 OSX 10.11.6 Apache 2.4.18 (Unix) PHP 5.5.36 設定 apache既然mac都已經內建好apache了，就先來啟動apache server看看吧！ 1$ sudo apachectl start 如果可以連到 localhost 就表示成功了！ 接下來就是一些apache的設定等等了， 像我就會把port設成1337然後引入一些需要的module等等。 設定檔位置在 /etc/apache2/httpd.conf ， 在finder下 cmd + shift + g 直接輸入上述位置即可。 我自己的httpd.conf主要是改這些東西： port 改成 1337 1Listen 1337 載入需要的模組 （也就是把前面的＃拿掉） 12LoadModule rewrite_module libexec/apache2/mod_rewrite.so&lt;/span&gt;LoadModule php5_module libexec/apache2/libphp5.so 啟用 Virtual hosts 12# Virtual hostsInclude /private/etc/apache2/extra/httpd-vhosts.conf 加入路徑讀取權限 如果不加，會發生 因為沒有權限而存取被拒的問題。（client denied by server configuration ） 這好像是比較偷懶的權限設法，因為是本地開發沒關係， 對外可能就不是這樣寫了XD 路徑我自己是設成這樣 /Users/tri613/workspace/www/ 123456&lt;Directory &quot;/your/path/to/site/documents&quot;&gt; Options Indexes MultiViews FollowSymLinks AllowOverride All # Apache 2.4 Require all granted&lt;/Directory&gt; 設定user / group 也是跟權限有關的設定，對linux(unix)不是特熟所以只是先設著保險（？） 12User your_user_name Group staff 最後記得伺服器要重開剛才套用的東西才會有作用！ 1$ sudo apachectl restart 設置 virtual host設置virtual hosts就只要修改 etc/apache2/extra/httpd-vhosts.conf 這個檔案就可以了！ 123456789101112131415# httpd-vhosts.conf# 第一個是如果沒有符合的網址，就會導到這裡&lt;VirtualHost *:1337&gt; DocumentRoot &quot;/your/project/site&quot; ServerName my.default.site.local ErrorLog &quot;/your/logs/error.log&quot;&lt;/VirtualHost&gt;# 之後的就隨意了&lt;VirtualHost *:1337&gt; DocumentRoot &quot;/Users/tri613/workspace/www/my-project&quot; ServerName myproject.local ErrorLog &quot;/Users/tri613/workspace/www/log/myproject@error_log&quot;&lt;/VirtualHost&gt; 以上內容只是範例啦，我都很懶惰只有指定這幾項而已ＸＤ 另外就是要注意 etc/hosts 這隻檔案要加上hosts， 不然打剛剛自己設定的網址是會找不到的。123# etc/hosts# 以上面的virtual hosts為例127.0.0.1 myproject.local 大致上就是這些！ 安裝 Mysql先去官方網站下載，然後安裝，結束～～～（誤） 安裝過程會有一串預設的密碼要記著， 不然到時候沒密碼會登不進去。 安裝好了以後，要記得先到 系統偏好設定 裡面找到mysql並把mysql server開啟，不然不能用的。 接下來就先加環境變數吧！（我絕對不會說我為了加這個把其他的指令都蓋掉惹）12# 一開始應該都不會有這個檔案，所以就建一個新的$ touch ~/.bash_profile 然後在 .bash_profile 裡面加上1export PATH=/usr/local/mysql/bin:$PATH 這行就可以了！ 接下來就是一些mysql的初始設定等等摟。12345//首次登入$ mysql -u root -p //輸入剛才安裝中給的預設密碼//登入成功後，要先換密碼mysql &gt; SET PASSWORD = PASSWORD('your_new_password'); 到這裡就可以用root身份進行一般mysql操作了，通常後續還會創root以外的使用者等等的，但因為是本地開發所以就先忽略哈哈。 確定mysql可以用了以後，就是把PHP跟mysql連在一起啦～1234cd /varmkdir mysqlcd mysqlln -s /tmp/mysql.sock mysql.sock 到這裡就完成基本的MAMP架設啦～ 雖然感覺很簡單但我也是裝了兩遍啊哈哈哈～～～（謎 參考資料 [Mac]不用懶人包，在 OS X 上安裝 Apache, PHP, MySQL Apache2: ‘AH01630: client denied by server configuration’","categories":[],"tags":[{"name":"mamp","slug":"mamp","permalink":"http://tri613.github.io/tags/mamp/"},{"name":"osx","slug":"osx","permalink":"http://tri613.github.io/tags/osx/"}]},{"title":"Network settings for virtualbox","slug":"vm-network-settings","date":"2016-11-21T08:49:04.000Z","updated":"2017-09-20T03:16:10.622Z","comments":true,"path":"2016/11/21/vm-network-settings/","link":"","permalink":"http://tri613.github.io/2016/11/21/vm-network-settings/","excerpt":"※ 2017/09/20 更新 Ubuntu 16.04 VM: CentOS 6.5 / Ubuntu 16.04 Host: Windows7","text":"※ 2017/09/20 更新 Ubuntu 16.04 VM: CentOS 6.5 / Ubuntu 16.04 Host: Windows7 VM 設定 網卡設定 第一張設 NAT 第二張設 橋接介面卡 CentOS 6.5 確認 VM 網卡設定 1$ ifconfig 確認兩張網卡都有開 eth0 / eth1 沒有的話，就啟動網卡1$ ifconfig &#123;eth0|eth1&#125; &#123;up|down&#125; VM網卡設定 1$ vim /etc/sysconfig/network-scripts/ifcfg-&#123;eth0|eth1&#125; eth0 (NAT) 基本上原本的設定就好，不用改 12345DEVICE=eth0BOOTPROTO=dhcpHWADDR=08:00:27:92:0E:1F #your mac addressONBOOT=yesTYPE=Ethernet eth1 (橋接) 12345678910DEVICE=eth1#BOOTPROTO=none#BROADCAST=192.168.XXX.255HWADDR=08:00:27:79:90:9d #your mac addressIPADDR=192.168.XXX.VVVNETMASK=255.255.255.0#NETWORK=192.168.XXX.0ONBOOT=yes#GATEWAY=192.168.XXX.1TYPE=Ethernet 設定完記得重啟 1$ /etc/init.d/network restart 檢查連線 &amp; you’re good to go! 其他設定 關閉防火牆 1$ service iptables stop 設定開機時不會開起防火牆 1$ chkconfig iptables off Ubuntu 16.04 先確認有哪些網卡 1$ ip addr 進入 /etc/network/interfaces 修改檔案 1$ sudo vim /etc/network/interfaces 123456789101112131415161718# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto enp0s3iface enp0s3 inet dhcp# 以下為 橋接網卡 主要新增的部分 (上面都是預設的，不用改)auto enp0s8iface enp0s8 inet staticaddress 192.168.13.14netmask 255.255.255.0 重啟連線 1$ sudo /etc/init.d/networking restart Check and done! 1$ ping 8.8.8.8 本機設定 確定有加網路區段 (Windows) 區域連線 &gt; IPv4 &gt; 進階 &gt; IP設定 增加和VM同網段的IP位址 192.168.XXX.LLL 檢查是否連得到 VM 1$ ping 192.168.XXX.VVV 備註（以下筆記） VMware Player 的 host OS 和 guest OS 之間有三種網路型態： Bridged Networking在這種網路型態之下，guest OS 是透過一個 virtual bridge 和 host OS 所在的 Ethernet 相連，請參考 VMware 的官方 示意圖。 對 於與 host OS 同在一個 Ethernet 上的機器來說，guest OS 和 host OS 是兩台獨立的電腦，都可以透過同一個 Ethernet 介面連接，並無法分辨出這兩個 OS 其實是在同一台機器上執行。甚至當 Ethernet 連線出問題時，guest OS 和 host OS 也不能互通 (即使是在同一台機器之內)。 換句話說，當你把接到 host OS 的網路線拔掉時，這兩個 OS 就無法溝通。因此，想把 VMware Player 灌在 notebook 上帶著跑的人，這種網路型態是不太合適的。 Host-Only Networking在 這種網路型態之下，guest OS 和 host OS 是在一個與世隔絕的虛擬網路上。此虛擬網路有一個 DHCP server，可以分配 IP address 給 guest OS 和 host OS (分配給一個虛擬的介面)。因此，guest OS 和 host OS 可以互通。請參考 VMware 的官方示意圖。 對 於與 host OS 同在一個 Ethernet 上的機器來說，guest OS 是看不見的。guest OS 對外聯繫的唯一管道就是 host OS。因此，guest OS 若想連上外部網路或 Internet，就必須在 host OS 安裝 routing 或 NAT 的服務。 這種架構不會受到實體網路的影響，即使把網路線拔掉，host OS 和 guest OS 還是可以互通。 Network Address Translation (NAT)此種網路型態與 host-only networking 的架構很像，但是在虛擬網路上多了一台 NAT router。請參考 VMware 的官方示意圖。 因為有了這台虛擬的 NAT router，guest 雖然與外界隔離，但仍然可以很方便地透過連接在 host OS 的網路連接 Internet。 這種架構也不會受到實體網路的影響，即使把網路線拔掉，host OS 和 guest OS 還是可以互通。若連接到 host OS 的 Internet 連線沒有問題，guest OS 也一樣可以連接到 Internet。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://tri613.github.io/tags/linux/"},{"name":"vm","slug":"vm","permalink":"http://tri613.github.io/tags/vm/"},{"name":"network","slug":"network","permalink":"http://tri613.github.io/tags/network/"}]},{"title":"css fallback for IE(11+)","slug":"css-fallback-for-ie","date":"2016-11-21T08:45:40.000Z","updated":"2017-06-20T05:23:11.850Z","comments":true,"path":"2016/11/21/css-fallback-for-ie/","link":"","permalink":"http://tri613.github.io/2016/11/21/css-fallback-for-ie/","excerpt":"我也不知道我當初為什麼會硬著頭皮寫英文的，反正就是英文的了哈哈哈","text":"我也不知道我當初為什麼會硬著頭皮寫英文的，反正就是英文的了哈哈哈 1. grayscale 12-webkit-filter:grayscale(100%);filter:grayscale(100%); use javascript. see tutorial here. or just simply use picture in gray. (haha) 2. object-fit / object-position1234-o-object-fit:cover; object-fit:cover;-o-object-position:center; object-position:center; IE doesn’t support object-fit after IE10,so use background-size and background-position instead. 3. vertical centering with css translateAs the question asked here,when using css translate to center contents,after scrolling the webpage, IE would somehow translate dom elements in the way that were not expected. This is what i encountered: The original page looks like this.After scrolling to other section(with jquery), the first section was “moved up”. The html and css:12345678910111213&lt;!-- the first section in the picture --&gt;&lt;div class=\"page\" id=\"first-section\"&gt; &lt;div class=\"page-content\"&gt; &lt;!-- some contents here --&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- some other sections --&gt;&lt;div class=\"page\"&gt; &lt;div class=\"page-content\" id=\"other-section\"&gt; &lt;!-- some contents here --&gt; &lt;/div&gt;&lt;/div&gt;... 1234567891011.page &#123; height: 100vh; min-height: 850px;&#125;.page-content &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); -webkit-transform: translate(-50%, -50%);&#125; I found out it’s the css in .page-content that caused the unexpected translation (in IE only of course),so after using bottom and right instead of top and right as suggested,everything works fine magically again! 12345678/* this works in IE (and all other browsers) */.page-content &#123; position: absolute; bottom: 50%; right: 50%; transform: translate(50%,50%); -webkit-transform: translate(50%,50%);&#125; Guess this is just some kind of bug in IE, since this doesn’t happen in other browsers. Stupid IE.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://tri613.github.io/tags/css/"},{"name":"ie","slug":"ie","permalink":"http://tri613.github.io/tags/ie/"}]},{"title":":nth-child v.s. :nth-of-type","slug":"nth-child-vs-nth-of-type","date":"2016-11-21T07:55:37.000Z","updated":"2017-06-20T05:23:34.336Z","comments":true,"path":"2016/11/21/nth-child-vs-nth-of-type/","link":"","permalink":"http://tri613.github.io/2016/11/21/nth-child-vs-nth-of-type/","excerpt":"一直搞混所以認真研究一下他們的不同之處。","text":"一直搞混所以認真研究一下他們的不同之處。 :nth-child:nth-child 最容易誤會的地方是，它並不是搜尋父元素下的第幾個順序的selector子元素，而是單純在父元素下的第幾個子元素，基本上跟元素本身type或selector無關，selector只是附加限制條件。 12345678910&lt;div class=\"parent\"&gt; &lt;div class=\"child-div\"&gt;&lt;/div&gt; &lt;!-- .parent .child-div:nth-child(1) --&gt; &lt;div class=\"child-div\"&gt;&lt;/div&gt; &lt;!-- .parent .child-div:nth-child(2) --&gt; &lt;a class=\"child-a\"&gt;&lt;/a&gt; &lt;!-- .parent .child-a:nth-child(3) --&gt; &lt;a class=\"child-a\"&gt;&lt;/a&gt; &lt;!-- .parent .child-a:nth-child(4) --&gt;&lt;/div&gt; 123456.parent .child-div:nth-child(2) &#123; color:red; /* this will work */&#125;.parent .child-a:nth-child(1) &#123; color:blue; /* this won't work */&#125; :nth-of-type:nth-of-type 就比較偏向搜尋某個父元素下面的第幾個指定類型的子元素，但要注意的是它只能指定html的本身的種類（像是&lt;a&gt;、&lt;div&gt;等等），而不能用class名稱做為selector。 12345678910&lt;div class=\"parent\"&gt; &lt;div class=\"child-div\"&gt;&lt;/div&gt; &lt;!-- .parent div:nth-of-type(1) --&gt; &lt;div class=\"child-div\"&gt;&lt;/div&gt; &lt;!-- .parent div:nth-of-type(2) --&gt; &lt;a class=\"child-a\"&gt;&lt;/a&gt; &lt;!-- .parent a:nth-of-type(1) --&gt; &lt;a class=\"child-a\"&gt;&lt;/a&gt; &lt;!-- .parent a:nth-of-type(2) --&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://tri613.github.io/tags/css/"}]}]}